import logging
from sqlalchemy import text, quoted_name
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.exc import IntegrityError
from .db_connection import engine, Base, SessionLocal
from app.core.security import hash_password
from app.api.mensura.models.user_model import UserModel

logger = logging.getLogger(__name__)
SCHEMAS = ["mensura", "bi", "delivery", "pdv"]

def ensure_unaccent():
    with engine.connect() as conn:
        conn.execute(text("CREATE EXTENSION IF NOT EXISTS unaccent;"))
        conn.commit()
        logger.info("unaccent instalado com sucesso")

def ensure_postgis():
    try:
        with engine.connect() as conn:
            # Verifica se a extens√£o PostGIS est√° dispon√≠vel
            result = conn.execute(text("""
                SELECT EXISTS(
                    SELECT 1 FROM pg_available_extensions 
                    WHERE name = 'postgis'
                );
            """))
            is_available = result.scalar()
            
            if is_available:
                conn.execute(text("CREATE EXTENSION IF NOT EXISTS postgis;"))
                conn.commit()
                logger.info("PostGIS instalado com sucesso")
            else:
                logger.warning("PostGIS n√£o est√° dispon√≠vel no servidor PostgreSQL. Pulando instala√ß√£o.")
    except Exception as e:
        logger.warning(f"Erro ao instalar PostGIS: {e}. Continuando sem PostGIS.")

def criar_schemas():
    try:
        with engine.begin() as conn:
            for schema in SCHEMAS:
                logger.info(f"üõ†Ô∏è Criando/verificando schema: {schema}")
                conn.execute(text(f'CREATE SCHEMA IF NOT EXISTS {quoted_name(schema, quote=True)}'))
        logger.info("‚úÖ Todos os schemas verificados/criados.")
    except Exception as e:
        logger.error(f"‚ùå Erro ao criar schemas: {e}")

def importar_models():
    # ‚îÄ‚îÄ‚îÄ Models Mensura ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    from app.api.mensura.models.empresa_model import EmpresaModel
    from app.api.mensura.models.user_model import UserModel
    from app.api.mensura.models.endereco_model import EnderecoModel
    from app.api.mensura.models.cadprod_emp_model import ProdutoEmpModel
    from app.api.mensura.models.cadprod_model import ProdutoModel
    # ‚îÄ‚îÄ‚îÄ Models Delivery ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    from app.api.delivery.models.model_transacao_pagamento_dv import TransacaoPagamentoModel
    from app.api.delivery.models.model_pedido_dv import PedidoDeliveryModel
    from app.api.delivery.models.model_pedido_item_dv import PedidoItemModel
    from app.api.delivery.models.model_pedido_status_historico_dv import PedidoStatusHistoricoModel
    from app.api.delivery.models.model_cupom_dv import CupomDescontoModel
    from app.api.delivery.models.model_cliente_dv import ClienteDeliveryModel
    from app.api.delivery.models.model_endereco_dv import EnderecoDeliveryModel
    from app.api.delivery.models.model_categoria_dv import CategoriaDeliveryModel
    from app.api.delivery.models.model_vitrine_dv import VitrinesModel
    from app.api.delivery.models.model_entregador_dv import EntregadorDeliveryModel
    from app.api.delivery.models.model_meio_pagamento_dv import MeioPagamentoModel
    from app.api.delivery.models.model_cliente_codigo_validacao import ClienteOtpModel
    from app.api.delivery.models.model_parceiros_dv import BannerParceiroModel, ParceiroModel
    from app.api.delivery.models.model_regiao_entrega import RegiaoEntregaModel

    logger.info("üì¶ Models importados com sucesso.")

def criar_tabelas_criticas():
    """Cria tabelas cr√≠ticas que s√£o depend√™ncias de outras tabelas"""
    try:
        # Cria mensura.enderecos primeiro (depend√™ncia de empresas)
        with engine.connect() as conn:
            conn.execute(text("""
                CREATE TABLE IF NOT EXISTS mensura.enderecos (
                    id SERIAL PRIMARY KEY,
                    logradouro VARCHAR(255) NOT NULL,
                    numero VARCHAR(20),
                    complemento VARCHAR(100),
                    bairro VARCHAR(100) NOT NULL,
                    cidade VARCHAR(100) NOT NULL,
                    uf VARCHAR(2) NOT NULL,
                    cep VARCHAR(9),
                    latitude NUMERIC(10, 6),
                    longitude NUMERIC(10, 6),
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
                    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
                );
            """))
            conn.commit()
            logger.info("‚úÖ Tabela mensura.enderecos criada/verificada com sucesso")
            
        # Cria mensura.cadprod (depend√™ncia de cadprod_emp)
        with engine.connect() as conn:
            conn.execute(text("""
                CREATE TABLE IF NOT EXISTS mensura.cadprod (
                    cod_barras VARCHAR PRIMARY KEY,
                    descricao VARCHAR(255) NOT NULL,
                    imagem VARCHAR(255),
                    data_cadastro DATE,
                    cod_categoria INTEGER,
                    ativo BOOLEAN NOT NULL DEFAULT TRUE,
                    unidade_medida VARCHAR(10),
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
                    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
                );
            """))
            conn.commit()
            logger.info("‚úÖ Tabela mensura.cadprod criada/verificada com sucesso")
    except Exception as e:
        logger.error(f"‚ùå Erro ao criar tabelas cr√≠ticas: {e}")

def criar_tabelas():
    try:
        # Primeiro cria tabelas cr√≠ticas
        logger.info("üîß Criando tabelas cr√≠ticas...")
        criar_tabelas_criticas()
        
        importar_models()  # importa s√≥ os seus models de mensura e delivery

        # pega todas as Table objects que o Base conhece
        all_tables = list(Base.metadata.tables.values())
        logger.info(f"üìä Total de tabelas encontradas: {len(all_tables)}")

        # filtra pelas tabelas que pertencem aos schemas que voc√™ gerencia
        tables_para_criar = [
            t
            for t in all_tables
            if t.schema in SCHEMAS
        ]
        
        logger.info(f"üìã Tabelas para criar nos schemas {SCHEMAS}:")
        for table in tables_para_criar:
            logger.info(f"  - {table.schema}.{table.name}")

        # Ordena√ß√£o simples: cria tabelas na ordem que aparecem nos models
        # O SQLAlchemy j√° resolve as depend√™ncias automaticamente
        ordered_tables = tables_para_criar

        logger.info("üîß Criando tabelas na ordem correta:")
        for table in ordered_tables:
            logger.info(f"  - {table.schema}.{table.name}")

        # Cria as tabelas na ordem correta
        for table in ordered_tables:
            try:
                table.create(engine, checkfirst=True)
                logger.info(f"‚úÖ Tabela {table.schema}.{table.name} criada com sucesso")
            except Exception as table_error:
                # Se for erro de duplica√ß√£o, apenas avisa (n√£o √© cr√≠tico)
                if "duplicate key value violates unique constraint" in str(table_error) or "already exists" in str(table_error):
                    logger.info(f"‚ÑπÔ∏è Tabela {table.schema}.{table.name} j√° existe (pulando)")
                elif "does not exist" in str(table_error):
                    # Se a tabela referenciada n√£o existe, tenta criar novamente no final
                    logger.warning(f"‚ö†Ô∏è Tabela {table.schema}.{table.name} falhou por depend√™ncia. Tentando novamente...")
                    try:
                        table.create(engine, checkfirst=True)
                        logger.info(f"‚úÖ Tabela {table.schema}.{table.name} criada com sucesso na segunda tentativa")
                    except Exception as retry_error:
                        logger.error(f"‚ùå Erro persistente ao criar tabela {table.schema}.{table.name}: {retry_error}")
                else:
                    logger.error(f"‚ùå Erro ao criar tabela {table.schema}.{table.name}: {table_error}")
                # Continua com as pr√≥ximas tabelas mesmo se uma falhar

        # Segunda passada para tabelas que falharam por depend√™ncias
        logger.info("üîÑ Segunda passada para tabelas com depend√™ncias...")
        for table in ordered_tables:
            try:
                # Verifica se a tabela j√° existe
                with engine.connect() as conn:
                    result = conn.execute(text(f"""
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables 
                            WHERE table_schema = '{table.schema}' 
                            AND table_name = '{table.name}'
                        );
                    """))
                    exists = result.scalar()
                    
                if not exists:
                    table.create(engine, checkfirst=True)
                    logger.info(f"‚úÖ Tabela {table.schema}.{table.name} criada na segunda passada")
            except Exception as second_pass_error:
                if "already exists" not in str(second_pass_error):
                    logger.error(f"‚ùå Erro na segunda passada para {table.schema}.{table.name}: {second_pass_error}")

        logger.info("‚úÖ Processo de cria√ß√£o de tabelas conclu√≠do.")
    except Exception as e:
        logger.error(f"‚ùå Erro geral ao criar tabelas: {e}", exc_info=True)

def criar_usuario_admin_padrao():
    """Cria o usu√°rio 'admin' com senha padr√£o caso n√£o exista."""
    try:
        with SessionLocal() as session:
            stmt = (
                insert(UserModel)
                .values(
                    username="super",
                    hashed_password=hash_password("171717"),
                    type_user="admin",
                )
                .on_conflict_do_nothing(index_elements=[UserModel.username])
            )
            result = session.execute(stmt)
            session.commit()
            if hasattr(result, "rowcount") and result.rowcount == 0:
                logger.info("üîπ Usu√°rio admin j√° existe. Pulando cria√ß√£o.")
            else:
                logger.info("‚úÖ Usu√°rio admin criado com sucesso (senha padr√£o: 123456).")
    except IntegrityError:
        # Em caso de corrida entre m√∫ltiplos processos
        try:
            session.rollback()
        except Exception:
            pass
        logger.info("üîπ Usu√°rio admin j√° existe (detectado por integridade).")
    except Exception as e:
        logger.error(f"‚ùå Erro ao criar usu√°rio admin: {e}", exc_info=True)

def inicializar_banco():
    logger.info("üîπ Instalando extens√µes...")
    ensure_unaccent()
    ensure_postgis()
    logger.info("üîπ Criando schemas...")
    criar_schemas()
    logger.info("üîπ Criando tabelas...")
    criar_tabelas()
    logger.info("üîπ Garantindo usu√°rio admin padr√£o...")
    criar_usuario_admin_padrao()
    logger.info("‚úÖ Banco inicializado com sucesso.")

